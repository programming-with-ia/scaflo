// --- Type Definitions ---
/** biome-ignore-all lint/suspicious/noExplicitAny: <explanation> */

import { getDeepValue } from "./utils";

/** Defines the shape of the context object passed to the evaluator. */
type Context = {
    // Allow nested objects for dot notation access.
    data: Record<string, any>;
    settings?: Record<string, any>;
    callbacks?: Record<string, (...args: any[]) => any>;
};

/** Defines the structure of a token generated by the tokenizer. */
type Token = {
    type: "OPERATOR" | "PAREN" | "CALLBACK" | "VALUE" | "LITERAL_VALUE";
    value: any;
};

/** Defines the structure for a tokenizer rule. */
type TokenSpec = {
    type: "WHITESPACE" | "OPERATOR" | "PAREN" | "CALLBACK" | "VALUE";
    re: RegExp;
};

export function evaluateWhen(expression: string, context: Context): boolean {
    // --- Helper Functions ---

    function getPrecedence(op: string): number {
        switch (op) {
            case "!":
                return 5;
            case "==":
            case "!=":
                return 4;
            case ">":
            case "<":
            case ">=":
            case "<=":
                return 3;
            case "&&":
                return 2;
            case "||":
                return 1;
            default:
                return -1;
        }
    }

    function isRightAssociative(op: string): boolean {
        return op === "!";
    }

    function applyOperator(operators: string[], values: any[]): void {
        const op = operators.pop();
        if (op === "!") {
            const right = values.pop();
            values.push(!right);
            return;
        }
        const right = values.pop();
        const left = values.pop();
        switch (op) {
            case "&&":
                values.push(Boolean(left) && Boolean(right));
                break;
            case "||":
                values.push(Boolean(left) || Boolean(right));
                break;
            case "==":
                values.push(left === right);
                break;
            case "!=":
                values.push(left !== right);
                break;
            case ">":
                values.push(left > right);
                break;
            case "<":
                values.push(left < right);
                break;
            case ">=":
                values.push(left >= right);
                break;
            case "<=":
                values.push(left <= right);
                break;
            default:
                throw new Error(`Unknown operator: ${op}`);
        }
    }

    function resolveTokenValue(token: { type: "VALUE"; value: string }): any {
        const { value } = token;

        if (value.startsWith("#"))
            return getDeepValue(context.data, value.slice(1));
        if (value.startsWith("@"))
            return getDeepValue(context.settings, value.slice(1));

        if (
            (value.startsWith("'") && value.endsWith("'")) ||
            (value.startsWith('"') && value.endsWith('"'))
        ) {
            return value.slice(1, -1);
        }
        if (value === "true") return true;
        if (value === "false") return false;
        if (!Number.isNaN(Number(value))) return Number(value);

        return undefined;
    }

    // --- 1. Tokenizer ---
    const tokenSpecs: TokenSpec[] = [
        { type: "WHITESPACE", re: /^\s+/ },
        { type: "OPERATOR", re: /^(==|!=|>=|<=|&&|\|\|)/ },
        { type: "OPERATOR", re: /^([!><])/ },
        { type: "PAREN", re: /^\(/ },
        { type: "PAREN", re: /^\)/ },
        { type: "CALLBACK", re: /^([A-Za-z_]\w*)\s*\(/ },
        {
            type: "VALUE",
            re: /^(@[\.A-Za-z_][\w.-]*|#[\.A-Za-z_][\w.-]*|'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|true|false|\d+(?:\.\d+)?)/,
        },
    ];

    let remaining = String(expression);
    const tokens: Token[] = [];

    while (remaining.length > 0) {
        let matched = false;
        for (const spec of tokenSpecs) {
            const m = remaining.match(spec.re);
            if (!m) continue;

            matched = true;

            if (spec.type === "WHITESPACE") {
                remaining = remaining.slice(m[0].length);
                break;
            }

            if (spec.type === "CALLBACK") {
                const funcName = m[1];
                let idx = m[0].length;
                let depth = 1;
                while (idx < remaining.length && depth > 0) {
                    const ch = remaining[idx];
                    if (ch === "(") depth++;
                    else if (ch === ")") depth--;
                    idx++;
                }
                if (depth !== 0)
                    throw new Error(
                        "Syntax Error: Unbalanced parentheses in callback call",
                    );

                const fullCall = remaining.slice(0, idx);
                const argsStr = fullCall.slice(m[0].length, idx - 1);

                const args =
                    argsStr.trim() === ""
                        ? []
                        : argsStr.split(",").map((a) =>
                              resolveTokenValue({
                                  type: "VALUE",
                                  value: a.trim(),
                              }),
                          );

                const fn = context.callbacks?.[funcName];
                if (typeof fn !== "function") {
                    throw new Error(`Unknown callback: ${funcName}`);
                }

                const result = fn(...args);
                tokens.push({ type: "LITERAL_VALUE", value: result });
                remaining = remaining.slice(fullCall.length);
                break;
            }

            tokens.push({ type: spec.type, value: m[0] });
            remaining = remaining.slice(m[0].length);
            break;
        }

        if (!matched) {
            throw new Error(
                `Syntax Error: Unrecognized token near "${remaining.slice(0, 20)}"`,
            );
        }
    }

    // --- 2. Evaluator ---
    const values: any[] = [];
    const ops: string[] = [];

    for (const token of tokens) {
        if (token.type === "LITERAL_VALUE") {
            values.push(token.value);
            continue;
        }

        if (token.type === "VALUE") {
            values.push(
                resolveTokenValue(token as { type: "VALUE"; value: string }),
            );
            continue;
        }

        if (token.type === "PAREN" && token.value === "(") {
            ops.push("(");
            continue;
        }

        if (token.type === "PAREN" && token.value === ")") {
            while (ops.length && ops[ops.length - 1] !== "(")
                applyOperator(ops, values);
            if (!ops.length)
                throw new Error("Syntax Error: Unbalanced parentheses");
            ops.pop();
            continue;
        }

        if (token.type === "OPERATOR") {
            const currentOp = token.value;
            while (ops.length) {
                const prevOp = ops[ops.length - 1];
                if (prevOp === "(") break;
                const prevPrec = getPrecedence(prevOp);
                const currPrec = getPrecedence(currentOp);
                if (
                    prevPrec > currPrec ||
                    (prevPrec === currPrec && !isRightAssociative(currentOp))
                ) {
                    applyOperator(ops, values);
                } else {
                    break;
                }
            }
            ops.push(currentOp);
            continue;
        }

        throw new Error(`Unexpected token: ${JSON.stringify(token)}`);
    }

    while (ops.length) applyOperator(ops, values);

    if (
        tokens.length === 1 &&
        tokens[0].type === "VALUE" &&
        (tokens[0].value.startsWith("#") || tokens[0].value.startsWith("@"))
    ) {
        const tokenValue = tokens[0].value;
        if (tokenValue.startsWith("#")) {
            const key = tokenValue.slice(1);
            return Object.hasOwn(context.data, key);
        }
        if (tokenValue.startsWith("@")) {
            const key = tokenValue.slice(1);
            return Object.hasOwn(context.settings || {}, key);
        }
    }

    return !!values[0];
}

// --- Demo ---

// function Demo(expression: string): boolean {
//     const context: Context = {
//         data: {
//             userRole: "admin",
//             loginAttempts: 3,
//             commentCount: 0, // A falsy number
//         },
//         settings: {
//             isMaintenanceMode: false, // A falsy boolean
//             scaflo: { styleColor: "green" },
//             "scaflo-styleColor": "green",
//             apiVersion: 2,
//         },
//         callbacks: {
//             isValidUser: (role: string) =>
//                 role === "admin" || role === "editor",
//         },
//     };
//     return evaluateWhen(expression, context);
// }

// console.log(`${Demo("@scaflo.styleColor=='green'")}`); // true
// console.log(`${Demo("@scaflo-styleColor=='green'")}`); // true

// console.log("--- Original Functionality (Unaffected) ---");
// console.log(`'isValidUser(#userRole) && !@isMaintenanceMode' is: ${Demo("isValidUser(#userRole) && !@isMaintenanceMode")}`); // true
// console.log(`'(@apiVersion == 2 || #loginAttempts > 5) && #userRole != 'editor'' is: ${Demo("(@apiVersion == 2 || #loginAttempts > 5) && #userRole != 'editor'")}`); // true

// console.log("\n--- New Standalone Key-Existence Logic ---");
// console.log(`'@isMaintenanceMode' is: ${Demo("@isMaintenanceMode")}`); // true (key exists)
// console.log(`'#commentCount' is: ${Demo("#commentCount")}`); // true (key exists)
// console.log(`'#nonExistentKey' is: ${Demo("#nonExistentKey")}`); // false
